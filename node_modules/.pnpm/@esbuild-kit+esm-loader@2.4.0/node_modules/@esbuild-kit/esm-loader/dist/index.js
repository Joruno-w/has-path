import y from"path";import{fileURLToPath as F,pathToFileURL as R}from"url";import{installSourceMapSupport as L,resolveTsPath as M,transform as P,applySourceMap as f,transformDynamicImport as O}from"@esbuild-kit/core-utils";import{parseTsconfig as A,getTsconfig as x,createPathsMatcher as C}from"get-tsconfig";import j from"fs";const u=L(),d=process.env.ESBK_TSCONFIG_PATH?{path:process.env.ESBK_TSCONFIG_PATH,config:A(process.env.ESBK_TSCONFIG_PATH)}:x(),v=d==null?void 0:d.config,S=d&&C(d),_=/\.([cm]?ts|[tj]sx)$/,k=t=>{const r=y.extname(t);if(r===".mjs"||r===".mts")return"module";if(r===".cjs"||r===".cts")return"commonjs"},g=new Map;async function $(t){if(g.has(t))return g.get(t);if(!await j.promises.access(t).then(()=>!0,()=>!1)){g.set(t,void 0);return}const s=await j.promises.readFile(t,"utf8");try{const o=JSON.parse(s);return g.set(t,o),o}catch{throw new Error(`Error parsing: ${t}`)}}async function B(t){let r=new URL("package.json",t);for(;!r.pathname.endsWith("/node_modules/package.json");){const s=F(r),o=await $(s);if(o)return o;const n=r;if(r=new URL("../package.json",r),r.pathname===n.pathname)break}}async function E(t){var r;const s=await B(t);return(r=s==null?void 0:s.type)!=null?r:"commonjs"}var H=Object.defineProperty,K=Object.defineProperties,V=Object.getOwnPropertyDescriptors,T=Object.getOwnPropertySymbols,G=Object.prototype.hasOwnProperty,q=Object.prototype.propertyIsEnumerable,U=(t,r,s)=>r in t?H(t,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[r]=s,D=(t,r)=>{for(var s in r||(r={}))G.call(r,s)&&U(t,s,r[s]);if(T)for(var s of T(r))q.call(r,s)&&U(t,s,r[s]);return t},N=(t,r)=>K(t,V(r));const z=[".js",".json",".ts",".tsx",".jsx"];async function I(t,r,s){let o;for(const n of z)try{return await h(t+n,r,s,!0)}catch(e){if(o===void 0){const{message:i}=e;e.message=e.message.replace(`${n}'`,"'"),e.stack=e.stack.replace(i,e.message),o=e}}throw o}async function J(t,r,s){const o=t.endsWith("/")?"index":"/index";try{return await I(t+o,r,s)}catch(n){const{message:e}=n;throw n.message=n.message.replace(`${o.replace("/",y.sep)}'`,"'"),n.stack=n.stack.replace(e,n.message),n}}const W="file://",Q=/^\.{0,2}\//,h=async function(t,r,s,o){var n,e;if(t.startsWith("node:")&&(t=t.slice(5)),t.endsWith("/"))return await J(t,r,s);const i=t.startsWith(W)||Q.test(t);if(S&&!i&&!((n=r.parentURL)!=null&&n.includes("/node_modules/"))){const a=S(t);for(const m of a)try{return await h(R(m).toString(),r,s)}catch{}}if(_.test(r.parentURL)){const a=M(t);if(a)try{return await h(a,r,s,!0)}catch(m){if(m.code!=="ERR_MODULE_NOT_FOUND")throw m}}let c;try{c=await s(t,r,s)}catch(a){if(a instanceof Error&&!o){if(a.code==="ERR_UNSUPPORTED_DIR_IMPORT")return await J(t,r,s);if(a.code==="ERR_MODULE_NOT_FOUND")return await I(t,r,s)}throw a}if(c.url.endsWith(".json"))return N(D({},c),{format:"json"});let{format:p}=c;return c.url.startsWith(W)&&(p=(e=k(c.url))!=null?e:p,p||(p=await E(c.url))),N(D({},c),{format:p})},X=async function(t,r,s){process.send&&process.send({type:"dependency",path:t}),t.endsWith(".json")&&(r.importAssertions||(r.importAssertions={}),r.importAssertions.type="json");const o=await s(t,r,s);if(!o.source)return o;const n=o.source.toString();if(o.format==="json"||_.test(t)){const i=await P(n,t,{tsconfigRaw:v});return{format:"module",source:f(i,t,u)}}const e=O(n);return e&&(o.source=f(e,t,u)),o},Y=async function(t,r,s){var o;return t.endsWith(".json")?{format:"module"}:t.startsWith("file:")?{format:(o=k(t))!=null?o:await E(t)}:await s(t,r,s)},Z=async function(t,r,s){const{url:o}=r;if(process.send&&process.send({type:"dependency",path:o}),o.endsWith(".json")||_.test(o)){const i=await P(t.toString(),o,{tsconfigRaw:v});return{source:f(i,o,u)}}const n=await s(t,r,s),e=O(n.source.toString());return e&&(n.source=f(e,o,u)),n},l=[16,12,0],w=process.version.slice(1).split(".").map(Number),b=(w[0]-l[0]||w[1]-l[1]||w[2]-l[2])<0,tt=b?Y:void 0,rt=b?Z:void 0;export{tt as getFormat,X as load,h as resolve,rt as transformSource};
